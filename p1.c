/*
  Arduino Nano POV Display (No Hall Sensor, ~200 RPM)
  - Uses micros() for precise timing
  - Includes text and pattern display modes
  - Easily customizable
*/

const int pins[] = {11, 10, 9, 8, 7, 6, 5, 4}; // 8 LED pins
const int rows = 8;
const int charWidth = 5;
const int charHeight = 8;

// Font for printable ASCII characters 32–126
const unsigned char font[95][5] = {
  {0x00,0x00,0x00,0x00,0x00}, // space
  {0x00,0x00,0x5F,0x00,0x00}, // !
  {0x00,0x07,0x00,0x07,0x00}, // "
  {0x14,0x7F,0x14,0x7F,0x14}, // #
  {0x24,0x2A,0x7F,0x2A,0x12}, // $
  {0x23,0x13,0x08,0x64,0x62}, // %
  {0x36,0x49,0x55,0x22,0x50}, // &
  {0x00,0x05,0x03,0x00,0x00}, // '
  {0x00,0x1C,0x22,0x41,0x00}, // (
  {0x00,0x41,0x22,0x1C,0x00}, // )
  {0x14,0x08,0x3E,0x08,0x14}, // *
  {0x08,0x08,0x3E,0x08,0x08}, // +
  {0x00,0x50,0x30,0x00,0x00}, // ,
  {0x08,0x08,0x08,0x08,0x08}, // -
  {0x00,0x60,0x60,0x00,0x00}, // .
  {0x20,0x10,0x08,0x04,0x02}, // /
  {0x3E,0x51,0x49,0x45,0x3E}, // 0
  {0x00,0x42,0x7F,0x40,0x00}, // 1
  {0x42,0x61,0x51,0x49,0x46}, // 2
  {0x21,0x41,0x45,0x4B,0x31}, // 3
  {0x18,0x14,0x12,0x7F,0x10}, // 4
  {0x27,0x45,0x45,0x45,0x39}, // 5
  {0x3C,0x4A,0x49,0x49,0x30}, // 6
  {0x01,0x71,0x09,0x05,0x03}, // 7
  {0x36,0x49,0x49,0x49,0x36}, // 8
  {0x06,0x49,0x49,0x29,0x1E}, // 9
  {0x00,0x36,0x36,0x00,0x00}, // :
  {0x00,0x56,0x36,0x00,0x00}, // ;
  {0x08,0x14,0x22,0x41,0x00}, // <
  {0x14,0x14,0x14,0x14,0x14}, // =
  {0x00,0x41,0x22,0x14,0x08}, // >
  {0x02,0x01,0x51,0x09,0x06}, // ?
  {0x32,0x49,0x79,0x41,0x3E}, // @
  {0x7E,0x09,0x09,0x09,0x7E}, // A
  {0x7F,0x49,0x49,0x49,0x36}, // B
  {0x3E,0x41,0x41,0x41,0x22}, // C
  {0x7F,0x41,0x41,0x22,0x1C}, // D
  {0x7F,0x49,0x49,0x49,0x41}, // E
  {0x7F,0x09,0x09,0x09,0x01}, // F
  {0x3E,0x41,0x49,0x49,0x7A}, // G
  {0x7F,0x08,0x08,0x08,0x7F}, // H
  {0x00,0x41,0x7F,0x41,0x00}, // I
  {0x20,0x40,0x41,0x3F,0x01}, // J
  {0x7F,0x08,0x14,0x22,0x41}, // K
  {0x7F,0x40,0x40,0x40,0x40}, // L
  {0x7F,0x02,0x04,0x02,0x7F}, // M
  {0x7F,0x04,0x08,0x10,0x7F}, // N
  {0x3E,0x41,0x41,0x41,0x3E}, // O
  {0x7F,0x09,0x09,0x09,0x06}, // P
  {0x3E,0x41,0x51,0x21,0x5E}, // Q
  {0x7F,0x09,0x19,0x29,0x46}, // R
  {0x26,0x49,0x49,0x49,0x32}, // S
  {0x01,0x01,0x7F,0x01,0x01}, // T
  {0x3F,0x40,0x40,0x40,0x3F}, // U
  {0x1F,0x20,0x40,0x20,0x1F}, // V
  {0x3F,0x40,0x38,0x40,0x3F}, // W
  {0x63,0x14,0x08,0x14,0x63}, // X
  {0x07,0x08,0x70,0x08,0x07}, // Y
  {0x61,0x51,0x49,0x45,0x43}  // Z
};

// --- custom pattern bitmaps (8×8) ---
const byte heart[8] = {0b00000000,0b01100110,0b11111111,0b11111111,0b11111111,0b01111110,0b00111100,0b00011000};
const byte smile[8] = {0b00111100,0b01000010,0b10100101,0b10000001,0b10100101,0b10011001,0b01000010,0b00111100};
const byte star [8] = {0b00011000,0b10111101,0b01111110,0b11111111,0b01111110,0b10111101,0b00011000,0b00000000};

// --- settings ---
char textString[] = "HI";
int motorRPM = 200;
bool showPattern = false;  // false = text, true = pattern

void setup() {
  for (int i=0;i<rows;i++){
    pinMode(pins[i], OUTPUT);
    digitalWrite(pins[i], LOW);
  }
}

// compute column delay in microseconds
float getColumnDelayMicros(int totalColumns) {
  float rotationTimeMs = 60000.0 / motorRPM;
  return (rotationTimeMs * 1000.0) / totalColumns;
}

void loop() {
  if(showPattern){
    displayPattern(heart);   // change to heart, smile, or star
  } else {
    displayText();
  }
}

// display text string
void displayText(){
  int totalColumns = strlen(textString) * (charWidth + 1);
  unsigned long colDelay = (unsigned long)getColumnDelayMicros(totalColumns);

  for(int c=0;c<strlen(textString);c++){
    char ch = textString[c];
    if(ch<32 || ch>126) continue;
    ch -= 32;
    for(int i=0;i<charWidth;i++){
      unsigned char colBits = font[(int)ch][i];
      unsigned long t0 = micros();
      for(int j=0;j<rows;j++)
        digitalWrite(pins[j], bitRead(colBits, j));
      while(micros()-t0 < colDelay);  // wait precise time
    }
    clearAll();
    unsigned long t0 = micros();
    while(micros()-t0 < colDelay); // gap between letters
  }
}

// display an 8×8 pattern
void displayPattern(const byte pattern[8]){
  unsigned long colDelay = (unsigned long)getColumnDelayMicros(8);
  for(int i=0;i<8;i++){
    unsigned long t0 = micros();
    for(int j=0;j<rows;j++)
      digitalWrite(pins[j], bitRead(pattern[i], j));
    while(micros()-t0 < colDelay);
  }
  clearAll();
}

void clearAll(){
  for(int i=0;i<rows;i++) digitalWrite(pins[i], LOW);
}
